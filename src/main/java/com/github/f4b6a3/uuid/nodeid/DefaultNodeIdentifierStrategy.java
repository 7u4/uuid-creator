package com.github.f4b6a3.uuid.nodeid;

import java.security.SecureRandom;
import java.util.Random;

import com.github.f4b6a3.uuid.util.NodeIdentifierUtil;

public class DefaultNodeIdentifierStrategy implements NodeIdentifierStrategy {

	protected long nodeIdentifier = 0;

	protected Random random = new SecureRandom();

	/**
	 * Return a random node identifier.
	 * 
	 * It uses {@link SecureRandom} to generate 'cryptographic quality random
	 * number'. The first generated number is returned for all calls.
	 * 
	 * ### RFC-4122 - 4.5. Node IDs that Do Not Identify the Host
	 * 
	 * (1) This section describes how to generate a version 1 UUID if an IEEE
	 * 802 address is not available, or its use is not desired.
	 * 
	 * (2) One approach is to contact the IEEE and get a separate block of
	 * addresses. At the time of writing, the application could be found at
	 * <http://standards.ieee.org/regauth/oui/pilot-ind.html>, and the cost was
	 * US$550.
	 * 
	 * (3) A better solution is to obtain a 47-bit cryptographic quality random
	 * number and use it as the low 47 bits of the node ID, with the least
	 * significant bit of the first octet of the node ID set to one. This bit is
	 * the unicast/multicast bit, which will never be set in IEEE 802 addresses
	 * obtained from network cards. Hence, there can never be a conflict between
	 * UUIDs generated by machines with and without network cards. (Recall that
	 * the IEEE 802 spec talks about transmission order, which is the opposite
	 * of the in-memory representation that is discussed in this document.)
	 * 
	 * @return
	 */
	@Override
	public long getNodeIdentifier() {

		if (this.nodeIdentifier != 0) {
			return this.nodeIdentifier;
		}

		this.nodeIdentifier = NodeIdentifierUtil.setMulticastNodeIdentifier(random.nextLong());
		return this.nodeIdentifier;
	}
}
